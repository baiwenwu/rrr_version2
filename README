修改了第一版的bug
详细的设计结构说明：
一，压缩结构
1,RRR算法将0/1串分成15 bits一个单位的小块，然后将它们按照块中1的个数分类成c0,c1,c2,...,c15共16个类别。其中ci表示这15 bits中共有i个1。
2,每个15 bits的单位对应着一个需要log(C(15,ci))的存储单元o。o表示这个小块在它同一类中的相对偏移量。有了这个相对偏移量，我们就能够利用(c,o)结构快速复原一个15 bits的小块。
3,这就是rrr算法的压缩结构。它对应着代码的rstable.hpp和rstable.cpp。其中存储c的表为R表，存储o的表为S表。解压还需要一个表，那就是在common中的DK类中的d表。之所以把d表放在common里面，是因为只要建立一张d表，就可以解压所有进行rrr压缩的数据。不必每次压缩一次建立一个d表。
二，rank查询结构
1,rank(i):从0到i中1的个数
2,分别对R表(存储c)和S表(存储d)建立索引结构
3,在R表上，我逻辑上将小块设计为15 * 32 bits，大块15 * 32 * 8bits。这样可以交叉存储大块和小块的索引值，因为小块需要9 bits，大块需要64 bits。共占空间不到1/30。对应代码中的rIndex。
4,在S表上，我建立了一级结构，15 * 32 bits当成一个逻辑块，占据了约1/7的空间，不太好。对应sIndex。
三，其它
其它的一些结构是为了使用的公用类，很好理解。
